<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Drawing NFT Platform - Pinata IPFS Upload</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      max-width: 1200px;
      margin: 0 auto;
      padding: 20px;
    }
    .container {
      background-color: #f9f9f9;
      padding: 20px;
      border-radius: 8px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
      margin-bottom: 20px;
    }
    .section {
      margin-bottom: 20px;
      padding-bottom: 20px;
      border-bottom: 1px solid #eee;
    }
    button {
      background-color: #4CAF50;
      border: none;
      color: white;
      padding: 10px 15px;
      text-align: center;
      text-decoration: none;
      display: inline-block;
      font-size: 14px;
      margin: 4px 2px;
      cursor: pointer;
      border-radius: 4px;
    }
    button:disabled {
      background-color: #cccccc;
      cursor: not-allowed;
    }
    input, textarea {
      width: 100%;
      padding: 8px;
      margin: 8px 0;
      display: inline-block;
      border: 1px solid #ccc;
      border-radius: 4px;
      box-sizing: border-box;
    }
    .status {
      font-weight: bold;
      color: #555;
    }
    .drawing-tools {
      display: flex;
      gap: 10px;
      margin-bottom: 10px;
      align-items: center;
    }
    canvas {
      border: 1px solid #ccc;
      border-radius: 4px;
      background-color: white;
    }
    .error {
      color: red;
      margin-top: 10px;
      padding: 10px;
      border: 1px solid red;
      background: #fff8f8;
    }
  </style>
</head>
<body>
  <h1>Drawing NFT Platform - Pinata IPFS Upload</h1>

  <div class="container">
    <div class="section">
      <h2>Connection</h2>
      <p>Status: <span id="status" class="status">Disconnected</span></p>
      <p>Account: <span id="account">Not connected</span></p>
      <button id="connectButton">Connect Wallet</button>
      <div id="errorMessage"></div>
    </div>

    <div id="creatorSection" class="section">
      <h2>Create and Mint Your Drawing NFT</h2>
      <div class="drawing-tools">
        <label for="brushColor">Brush Color:</label>
        <input type="color" id="brushColor" value="#000000">
        <label for="brushSize">Brush Size:</label>
        <input type="range" id="brushSize" min="1" max="50" value="5">
        <button id="clearCanvasButton">Clear Canvas</button>
      </div>
      <canvas id="drawingCanvas" width="600" height="400"></canvas>
      <input id="title" type="text" placeholder="Enter drawing title">
      <input id="royaltyPercentage" type="number" placeholder="Royalty percentage (0-1000 basis points)" max="1000">
      <button id="mintButton">Save to Pinata IPFS and Mint</button>
      <p>IPFS Hash: <span id="ipfsHashDisplay"></span></p>
      <div id="errorMessageIPFS"></div>
    </div>
  </div>

  <!-- Load Ethers.js and IPFS client -->
  <script src="ethers.min.js" type="application/javascript"></script>
  <script src="https://unpkg.com/ipfs-http-client@59.0.0/dist/index.min.js"></script>
  <script>
    // Check if IpfsHttpClient is available
    if (typeof window.IpfsHttpClient === 'undefined') {
      console.error("IpfsHttpClient is not loaded. Check the CDN script.");
      document.getElementById('errorMessage').innerHTML = `
        <div class="error">
          <p><strong>Error:</strong> Failed to load IPFS HTTP Client library. Please check your internet connection or try refreshing the page.</p>
        </div>
      `;
      throw new Error("IpfsHttpClient not loaded");
    }

    // Initialize IPFS client with Pinata using JWT
    const ipfs = window.IpfsHttpClient.create({
      host: 'gateway.pinata.cloud', // Use Pinata gateway
      port: 443,
      protocol: 'https',
      headers: {
        Authorization: `Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySW5mb3JtYXRpb24iOnsiaWQiOiJiN2ZkNTEwNS01NGVkLTQzNGItOWI4Ny0wYTA5ZTlkYjkwNTgiLCJlbWFpbCI6ImlhbmxpZWJlcm1hbjA3QGdtYWlsLmNvbSIsImVtYWlsX3ZlcmlmaWVkIjp0cnVlLCJwaW5fcG9saWN5Ijp7InJlZ2lvbnMiOlt7ImRlc2lyZWRSZXBsaWNhdGlvbkNvdW50IjoxLCJpZCI6IkZSQTEifSx7ImRlc2lyZWRSZXBsaWNhdGlvbkNvdW50IjoxLCJpZCI6Ik5ZQzEifV0sInZlcnNpb24iOjF9LCJtZmFfZW5hYmxlZCI6ZmFsc2UsInN0YXR1cyI6IkFDVElWRSJ9LCJhdXRoZW50aWNhdGlvblR5cGUiOiJzY29wZWRLZXkiLCJzY29wZWRLZXlLZXkiOiJjNTI2NzQ3ZGUzYTU5YTNiNGFlNCIsInNjb3BlZEtleVNlY3JldCI6IjNiNDZkYjE5M2VmMzlmMDM1NjcyZmQ3ZTVjOTA2MjJiMzI5YmVmN2NkMzc5MTA5MGIxMDdiMzQ5MjU2MDU0OGQiLCJleHAiOjE3NzM4MDk5NjJ9.5gxD1PeCx_wd4uy9V7f8Ad2YXxddZtzuhqd4D9RkHSE` // Your JWT token
      }
    });

    // Contract details
    let contractAddress = "0x09496ed954dacbbc7f88a5b06fcf3c62e27ec9d2";
    const contractOwner = "0xEdbA99b7F64530A7b598223435CC4d9Ca766bd41";

    // Variables for contract interaction
    let provider, signer, contract;
    let userAddress = null;
    let isOwner = false;
    let abi = null;
    let canvasInitialized = false;
    let isConnecting = false;

    // DOM Elements
    const connectButton = document.getElementById('connectButton');
    const statusElement = document.getElementById('status');
    const accountElement = document.getElementById('account');
    const creatorSection = document.getElementById('creatorSection');
    const drawingCanvas = document.getElementById('drawingCanvas');
    const brushColor = document.getElementById('brushColor');
    const brushSize = document.getElementById('brushSize');
    const clearCanvasButton = document.getElementById('clearCanvasButton');
    const title = document.getElementById('title');
    const royaltyPercentage = document.getElementById('royaltyPercentage');
    const mintButton = document.getElementById('mintButton');
    const ipfsHashDisplay = document.getElementById('ipfsHashDisplay');
    const errorMessage = document.getElementById('errorMessage');
    const errorMessageIPFS = document.getElementById('errorMessageIPFS');

    // Canvas drawing setup
    const ctx = drawingCanvas.getContext('2d');
    if (!ctx) {
      console.error("Failed to get 2D context for canvas");
      errorMessage.innerHTML = '<div class="error"><p>Canvas context failed to initialize. Check browser compatibility.</p></div>';
      canvasInitialized = false;
    } else {
      canvasInitialized = true;
    }

    let isDrawing = false;
    let lastX = 0;
    let lastY = 0;

    if (canvasInitialized) {
      drawingCanvas.addEventListener('mousedown', startDrawing);
      drawingCanvas.addEventListener('mousemove', draw);
      drawingCanvas.addEventListener('mouseup', stopDrawing);
      drawingCanvas.addEventListener('mouseout', stopDrawing);
      clearCanvasButton.addEventListener('click', clearCanvas);
    }

    function startDrawing(e) {
      isDrawing = true;
      [lastX, lastY] = [e.offsetX, e.offsetY];
      console.log("Started drawing at:", lastX, lastY);
    }

    function draw(e) {
      if (!isDrawing) return;
      console.log("Drawing to:", e.offsetX, e.offsetY);
      ctx.beginPath();
      ctx.moveTo(lastX, lastY);
      ctx.lineTo(e.offsetX, e.offsetY);
      ctx.strokeStyle = brushColor.value;
      ctx.lineWidth = brushSize.value;
      ctx.lineCap = 'round';
      ctx.stroke();
      [lastX, lastY] = [e.offsetX, e.offsetY];
    }

    function stopDrawing() {
      isDrawing = false;
      console.log("Stopped drawing");
    }

    function clearCanvas() {
      if (canvasInitialized) {
        ctx.clearRect(0, 0, drawingCanvas.width, drawingCanvas.height);
      }
    }

    // Load ABI from file
    async function loadABI() {
      try {
        statusElement.innerText = "Loading contract ABI...";
        const response = await fetch('./abi.json');
        if (!response.ok) throw new Error(`HTTP error! Status: ${response.status}`);
        abi = await response.json();
        console.log("ABI loaded successfully:", abi.length, "entries");
        statusElement.innerText = "Contract ABI loaded successfully";
      } catch (error) {
        console.error("Error loading ABI:", error);
        statusElement.innerText = "Error loading ABI file";
        errorMessage.innerHTML = `
          <div class="error">
            <p><strong>Error:</strong> ${error.message}</p>
            <p>Please ensure:</p>
            <ul>
              <li>You are running this page from a web server</li>
              <li>The abi.json file is in the correct location</li>
              <li>CORS settings are enabled on your server</li>
            </ul>
          </div>
        `;
      }
    }

    // Initialize the page
    async function init() {
      statusElement.innerText = "Initializing...";
      await loadABI();
    }

    // Connect to wallet
    async function connectWallet() {
      if (isConnecting) {
        errorMessage.innerHTML = `
          <div class="error">
            <p><strong>Error:</strong> A wallet connection request is already in progress. Please wait.</p>
          </div>
        `;
        return;
      }

      isConnecting = true;
      connectButton.disabled = true;
      connectButton.textContent = "Connecting...";

      try {
        if (!abi) {
          alert("Contract ABI not loaded. Please refresh the page and try again.");
          return;
        }

        if (window.ethereum == null) {
          statusElement.innerText = "MetaMask not installed; using read-only defaults";
          provider = ethers.getDefaultProvider();
          contract = new ethers.Contract(contractAddress, abi, provider);
        } else {
          provider = new ethers.BrowserProvider(window.ethereum);
          await provider.send("eth_requestAccounts", []);
          signer = await provider.getSigner();
          userAddress = await signer.getAddress();
          const network = await provider.getNetwork();
          statusElement.innerText = `Connected to ${network.name || 'chain ID ' + network.chainId}`;

          contract = new ethers.Contract(contractAddress, abi, signer);
          const code = await provider.getCode(contractAddress);
          if (code === '0x' || code === '0x0') {
            throw new Error("No contract deployed at the specified address.");
          }

          const ownerAddress = await contract.owner();
          isOwner = (ownerAddress.toLowerCase() === userAddress.toLowerCase());

          statusElement.innerText = "Connected";
          accountElement.innerText = userAddress;
          creatorSection.style.display = "block";
        }
      } catch (error) {
        console.error("Connection error:", error);
        let errorMsg = error.message;
        if (error.code === -32002) {
          errorMsg = "A MetaMask connection request is already pending. Please open MetaMask, approve or deny the request, or try refreshing the page.";
        }
        statusElement.innerText = "Connection failed: " + errorMsg;
        errorMessage.innerHTML = `
          <div class="error">
            <p><strong>Error:</strong> ${errorMsg}</p>
          </div>
        `;
      } finally {
        isConnecting = false;
        connectButton.disabled = false;
        connectButton.textContent = "Connect Wallet";
      }
    }

    // Upload to Pinata IPFS and mint
    async function saveToPinataAndMint() {
      if (!canvasInitialized) {
        errorMessageIPFS.innerHTML = `
          <div class="error">
            <p><strong>Error:</strong> Canvas not initialized. Cannot proceed with minting.</p>
          </div>
        `;
        return;
      }

      const titleValue = title.value.trim();
      const royalty = parseInt(royaltyPercentage.value) || 0;

      if (!titleValue || royalty > 1000) {
        alert("Please provide a valid title and royalty percentage (max 1000 basis points).");
        return;
      }

      try {
        errorMessageIPFS.innerHTML = ""; // Clear previous errors
        statusElement.innerText = "Converting canvas to image...";

        // Convert canvas to Blob
        const dataUrl = drawingCanvas.toDataURL('image/png');
        const response = await fetch(dataUrl);
        const blob = await response.blob();

        // Log blob size for debugging
        const blobSize = blob.size / 1024; // Size in KB
        console.log("Blob size:", blobSize, "KB");

        statusElement.innerText = "Uploading to Pinata IPFS...";
        const result = await ipfs.add(blob);
        const ipfsHash = result.path;
        ipfsHashDisplay.innerText = ipfsHash;
        console.log("IPFS Hash:", ipfsHash);

        statusElement.innerText = "Minting NFT...";
        const tx = await contract.mintDrawingNFT(ipfsHash, titleValue, royalty, { value: await contract.mintPrice() });
        await tx.wait();
        statusElement.innerText = "NFT minted successfully!";
        clearCanvas();
        title.value = "";
        royaltyPercentage.value = "";
        ipfsHashDisplay.innerText = "";
      } catch (error) {
        console.error("Error uploading to Pinata IPFS or minting:", error);
        statusElement.innerText = "Error occurred";
        let errorMsg = "An error occurred while uploading to Pinata IPFS or minting.";
        let possibleIssues = `
          <ul>
            <li>Invalid Pinata JWT token</li>
            <li>Network connectivity issues</li>
            <li>File size limit exceeded (check Pinata limits)</li>
          </ul>
        `;

        // Check for specific Pinata error codes (e.g., 401, 403, 429)
        if (error.message.includes("401")) {
          errorMsg = "Unauthorized: Invalid Pinata JWT token.";
        } else if (error.message.includes("413")) {
          errorMsg = "File size limit exceeded. Check Pinata limits.";
        } else if (error.message.includes("network")) {
          errorMsg = "Network connectivity issue detected.";
        } else if (error.message.includes("404")) {
          errorMsg = "Endpoint not found. The Pinata API endpoint might be incorrect or deprecated.";
        }

        errorMessageIPFS.innerHTML = `
          <div class="error">
            <p><strong>Error:</strong> ${errorMsg}</p>
            <p>Possible issues:</p>
            ${possibleIssues}
            <p>Check the console for details.</p>
          </div>
        `;
      }
    }

    // Add event listeners
    connectButton.addEventListener('click', connectWallet);
    mintButton.addEventListener('click', saveToPinataAndMint);
    clearCanvasButton.addEventListener('click', clearCanvas);

    // Initialize the application
    init();
  </script>
</body>
</html>