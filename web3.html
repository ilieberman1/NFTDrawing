<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Drawing NFT Platform - Pinata IPFS Upload</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      max-width: 1200px;
      margin: 0 auto;
      padding: 20px;
    }
    .container {
      background-color: #f9f9f9;
      padding: 20px;
      border-radius: 8px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
      margin-bottom: 20px;
    }
    .section {
      margin-bottom: 20px;
      padding-bottom: 20px;
      border-bottom: 1px solid #eee;
    }
    button {
      background-color: #4CAF50;
      border: none;
      color: white;
      padding: 10px 15px;
      text-align: center;
      text-decoration: none;
      display: inline-block;
      font-size: 14px;
      margin: 4px 2px;
      cursor: pointer;
      border-radius: 4px;
    }
    button:disabled {
      background-color: #cccccc;
      cursor: not-allowed;
    }
    input, textarea {
      width: 100%;
      padding: 8px;
      margin: 8px 0;
      display: inline-block;
      border: 1px solid #ccc;
      border-radius: 4px;
      box-sizing: border-box;
    }
    .status {
      font-weight: bold;
      color: #555;
    }
    .drawing-tools {
      display: flex;
      gap: 10px;
      margin-bottom: 10px;
      align-items: center;
    }
    canvas {
      border: 1px solid #ccc;
      border-radius: 4px;
      background-color: white;
    }
    .error {
      color: red;
      margin-top: 10px;
      padding: 10px;
      border: 1px solid red;
      background: #fff8f8;
    }
  </style>
</head>
<body>
  <h1>Drawing NFT Platform - Pinata IPFS Upload</h1>

  <div class="container">
    <div class="section">
      <h2>Connection</h2>
      <p>Status: <span id="status" class="status">Disconnected</span></p>
      <p>Account: <span id="account">Not connected</span></p>
      <button id="connectButton">Connect Wallet</button>
      <div id="errorMessage"></div>
    </div>

    <div id="creatorSection" class="section">
      <h2>Create and Mint Your Drawing NFT</h2>
      <div class="drawing-tools">
        <label for="brushColor">Brush Color:</label>
        <input type="color" id="brushColor" value="#000000">
        <label for="brushSize">Brush Size:</label>
        <input type="range" id="brushSize" min="1" max=50" value="5">
        <button id="clearCanvasButton">Clear Canvas</button>
      </div>
      <canvas id="drawingCanvas" width="600" height="400"></canvas>
      <input id="title" type="text" placeholder="Enter drawing title">
      <input id="royaltyPercentage" type="number" placeholder="Royalty percentage (0-1000 basis points)" max="1000">
      <button id="mintButton">Save to Pinata IPFS and Mint</button>
      <p>IPFS Hash: <span id="ipfsHashDisplay"></span></p>
      <div id="errorMessageIPFS"></div>
    </div>
  </div>

  <!-- Load Ethers.js and IPFS client -->
  <script src="ethers.min.js" type="application/javascript"></script>
  <script src="https://unpkg.com/ipfs-http-client@60.0.2/dist/index.min.js"></script>
  <script>
    // Initialize IPFS client with Pinata
    const ipfs = window.IpfsHttpClient.create({
      host: 'api.pinata.cloud',
      port: 443,
      protocol: 'https',
      headers: {
        pinata_api_key: '705f67a5989f44d9f901', // Replace with your Pinata API Key
        pinata_secret_api_key: 'db19f55c6d13d9e1590939b22315e5681865f66363bf918fa9e2e8475be791d2' // Replace with your Pinata API Secret
      }
    });

    // Contract details
    let contractAddress = "0x09496ed954dacbbc7f88a5b06fcf3c62e27ec9d2"; // Replace with your deployed contract address
    const contractOwner = "0xEdbA99b7F64530A7b598223435CC4d9Ca766bd41"; // Replace with the owner's address

    // Variables for contract interaction
    let provider, signer, contract;
    let userAddress = null;
    let isOwner = false;
    let abi = null;

    // DOM Elements
    const connectButton = document.getElementById('connectButton');
    const statusElement = document.getElementById('status');
    const accountElement = document.getElementById('account');
    const creatorSection = document.getElementById('creatorSection');
    const drawingCanvas = document.getElementById('drawingCanvas');
    const brushColor = document.getElementById('brushColor');
    const brushSize = document.getElementById('brushSize');
    const clearCanvasButton = document.getElementById('clearCanvasButton');
    const title = document.getElementById('title');
    const royaltyPercentage = document.getElementById('royaltyPercentage');
    const mintButton = document.getElementById('mintButton');
    const ipfsHashDisplay = document.getElementById('ipfsHashDisplay');
    const errorMessage = document.getElementById('errorMessage');
    const errorMessageIPFS = document.getElementById('errorMessageIPFS');

    // Canvas drawing setup
    const ctx = drawingCanvas.getContext('2d');
    let isDrawing = false;
    let lastX = 0;
    let lastY = 0;

    drawingCanvas.addEventListener('mousedown', startDrawing);
    drawingCanvas.addEventListener('mousemove', draw);
    drawingCanvas.addEventListener('mouseup', stopDrawing);
    drawingCanvas.addEventListener('mouseout', stopDrawing);
    clearCanvasButton.addEventListener('click', clearCanvas);

    function startDrawing(e) {
      isDrawing = true;
      [lastX, lastY] = [e.offsetX, e.offsetY];
    }

    function draw(e) {
      if (!isDrawing) return;
      ctx.beginPath();
      ctx.moveTo(lastX, lastY);
      ctx.lineTo(e.offsetX, e.offsetY);
      ctx.strokeStyle = brushColor.value;
      ctx.lineWidth = brushSize.value;
      ctx.lineCap = 'round';
      ctx.stroke();
      [lastX, lastY] = [e.offsetX, e.offsetY];
    }

    function stopDrawing() {
      isDrawing = false;
    }

    function clearCanvas() {
      ctx.clearRect(0, 0, drawingCanvas.width, drawingCanvas.height);
    }

    // Load ABI from file
    async function loadABI() {
      try {
        statusElement.innerText = "Loading contract ABI...";
        const response = await fetch('./abi.json');
        if (!response.ok) throw new Error(`HTTP error! Status: ${response.status}`);
        abi = await response.json();
        console.log("ABI loaded successfully:", abi.length, "entries");
        statusElement.innerText = "Contract ABI loaded successfully";
      } catch (error) {
        console.error("Error loading ABI:", error);
        statusElement.innerText = "Error loading ABI file";
        errorMessage.innerHTML = `
          <div class="error">
            <p><strong>Error:</strong> ${error.message}</p>
            <p>Please ensure:</p>
            <ul>
              <li>You are running this page from a web server</li>
              <li>The abi.json file is in the correct location</li>
              <li>CORS settings are enabled on your server</li>
            </ul>
          </div>
        `;
      }
    }

    // Initialize the page
    async function init() {
      statusElement.innerText = "Initializing...";
      await loadABI();
    }

    // Connect to wallet
    async function connectWallet() {
      try {
        if (!abi) {
          alert("Contract ABI not loaded. Please refresh the page and try again.");
          return;
        }

        if (window.ethereum == null) {
          statusElement.innerText = "MetaMask not installed; using read-only defaults";
          provider = ethers.getDefaultProvider();
          contract = new ethers.Contract(contractAddress, abi, provider);
        } else {
          provider = new ethers.BrowserProvider(window.ethereum);
          await provider.send("eth_requestAccounts", []);
          signer = await provider.getSigner();
          userAddress = await signer.getAddress();
          const network = await provider.getNetwork();
          statusElement.innerText = `Connected to ${network.name || 'chain ID ' + network.chainId}`;

          contract = new ethers.Contract(contractAddress, abi, signer);
          const code = await provider.getCode(contractAddress);
          if (code === '0x' || code === '0x0') {
            throw new Error("No contract deployed at the specified address.");
          }

          const ownerAddress = await contract.owner();
          isOwner = (ownerAddress.toLowerCase() === userAddress.toLowerCase());

          statusElement.innerText = "Connected";
          accountElement.innerText = userAddress;
          creatorSection.style.display = "block";
        }
      } catch (error) {
        console.error("Connection error:", error);
        statusElement.innerText = "Connection failed: " + error.message;
        errorMessage.innerHTML = `
          <div class="error">
            <p><strong>Error:</strong> ${error.message}</p>
          </div>
        `;
      }
    }

    // Upload to Pinata IPFS and mint
    async function saveToPinataAndMint() {
      const titleValue = title.value.trim();
      const royalty = parseInt(royaltyPercentage.value) || 0;

      if (!titleValue || royalty > 1000) {
        alert("Please provide a valid title and royalty percentage (max 1000 basis points).");
        return;
      }

      try {
        errorMessageIPFS.innerHTML = ""; // Clear previous errors
        statusElement.innerText = "Converting canvas to image...";

        // Convert canvas to Blob
        const dataUrl = drawingCanvas.toDataURL('image/png');
        const response = await fetch(dataUrl);
        const blob = await response.blob();

        statusElement.innerText = "Uploading to Pinata IPFS...";
        const result = await ipfs.add(blob);
        const ipfsHash = result.path;
        ipfsHashDisplay.innerText = ipfsHash;
        console.log("IPFS Hash:", ipfsHash);

        statusElement.innerText = "Minting NFT...";
        const tx = await contract.mintDrawingNFT(ipfsHash, titleValue, royalty, { value: await contract.mintPrice() });
        await tx.wait();
        statusElement.innerText = "NFT minted successfully!";
        clearCanvas();
        title.value = "";
        royaltyPercentage.value = "";
        ipfsHashDisplay.innerText = "";
      } catch (error) {
        console.error("Error uploading to Pinata IPFS or minting:", error);
        statusElement.innerText = "Error occurred";
        errorMessageIPFS.innerHTML = `
          <div class="error">
            <p><strong>Error:</strong> ${error.message}</p>
            <p>Possible issues:</p>
            <ul>
              <li>Invalid Pinata API Key or Secret</li>
              <li>Network connectivity issues</li>
              <li>File size limit exceeded (check Pinata limits)</li>
            </ul>
            <p>Check the console for details.</p>
          </div>
        `;
      }
    }

    // Add event listeners
    connectButton.addEventListener('click', connectWallet);
    mintButton.addEventListener('click', saveToPinataAndMint);
    clearCanvasButton.addEventListener('click', clearCanvas);

    // Initialize the application
    init();
  </script>
</body>
</html>